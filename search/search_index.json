{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"0x00 - Introduction","text":"B.Y.O.S. - Bring Your Own Satellite <p>In this training class, attendees are introduced to the basics of satellite communication in a hands-on manner. Also, through the power of virtualization and open-source software, attendees will get a step-by-step guide to create their own personal satellite lab, while helping discover the fundamental principles of satellite communication, from orbital mechanics to data transmission protocols, as you design, simulate, and experiment with satellite systems in a risk-free, virtual environment.</p> <p>Unveil the secrets of satellite technology, gain hands-on experience with real-world scenarios, and configuring and controlling your virtual satellite. This unique learning experience equips you with the knowledge and practical skills needed to explore the possibilities of satellite communication. Unlock the universe of opportunities that satellite communication offers, right from your own laptop.</p>"},{"location":"#requirements","title":"Requirements","text":"<p>Virtual Machine Running Ubuntu 22.04 LTS or later with 4 Cores and at least 4GB of Ram. Its is recommend you have a disk size of 30 GB.</p> <p>Both <code>AMD64</code> and <code>ARM64</code> versions are supporting by this documentation. </p> <p>Note</p> <p>32-Bit (x86) Virtual Machines are NOT supported!</p>"},{"location":"#setting-up-your-virtual-machine","title":"Setting up your Virtual Machine","text":"<p>Before you get started, you need to get your virtual machine setup. First you will want to update and upgrade Ubuntu using the following commands: <pre><code>sudo apt update &amp;&amp; sudo apt dist-upgrade -y\n</code></pre></p> <p> </p> Updating OS <p>Depending on how long it has been since you last updated your virtual machine, it may take a few moments. Once it is done, you need to install the only dependency for this workshop, <code>Docker</code> and all of its components. The easiest way to accomplish this is to install <code>docker-compose</code> using the following command:</p> <pre><code>sudo apt install docker-compose -y\n</code></pre> <p> </p> Installed Docker and Dependencies <p>Once <code>Docker</code> and its components are installed, you will want to add your user account to the <code>docker</code> group using the following commands:</p> <pre><code>sudo groupadd docker\nsudo usermod -aG docker $USER\n</code></pre> <p>!!!     You may get a message that the group <code>docker</code> already exists - if so, just ignore it</p> <p>Lastly to have make sure the rights of the <code>docker</code> group are assessible to your user, you should log off of your VM and then log back in.   </p> <p>Once logged back in to your VM, you can open a terminal, <code>ctrl + alt + t</code> works well to do that, and then run the following command to make sure you are able to run Docker with no issues: <code>docker version</code></p> <p> </p> Docker Version Output <p>If you output looks similar to above, you are ready to go.</p> <p>Note</p> <p>If you get an permissions error, you will need to run all Docker related commands with <code>sudo</code> prepended such as <code>sudo docker version</code> as well as OpenC3 commands.</p>"},{"location":"bring_your_own/","title":"Bring Your Own Satellite","text":"<pre><code>                     _    _            _     _____                       _____            \n                    | |  | |          | |   / ____|                     / ____|           \n                    | |__| | __ _  ___| | _| (___  _ __   __ _  ___ ___| |     ___  _ __  \n                    |  __  |/ _` |/ __| |/ /\\___ \\| '_ \\ / _` |/ __/ _ \\ |    / _ \\| '_ \\ \n                    | |  | | (_| | (__|   &lt; ____) | |_) | (_| | (_|  __/ |___| (_) | | | |\n                    |_|  |_|\\__,_|\\___|_|\\_\\_____/| .__/ \\__,_|\\___\\___|\\_____\\___/|_| |_|\n                                                | |                                     \n                                                |_|                                     \n</code></pre> <p><pre><code>docker run --net=openc3-cosmos-network --name HackSpaceCon -p1234:1234/udp -p1337:1337 --rm hackethos/hsc-1\n</code></pre> </p> <p></p> <p>In a new terminal window, you can then run the following command to download the pre-generated COMSOS plugin:</p> <p><code>wget https://byos.ethoslabs.space/openc3-cosmos-hackspacecon-1-1.0.0.gem</code></p> <p>OR you click the following link from within your VM's browser:</p> <p>Click Here: Download HSC-1 Plugin</p> <p></p> <p><code>docker network inspect openc3-cosmos-network</code></p> <p></p> <p></p> <p>click select</p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p>"},{"location":"build_your_own/","title":"Build Your Own Satellite","text":"<pre><code>mkdir BYOS &amp;&amp; cd BYOS\n</code></pre> <p><code>nano sat.py</code></p> <pre><code>import socket\nimport random\nimport struct\n\n# UDP IP and Ports\nLISTEN_IP = \"0.0.0.0\"\nCOMMAND_PORT = 1235\nTELEMETRY_PORT = 1234\nTELEMETRY_IP = \"openc3-operator\"  # Change if the client is on a different machine\n\n# Simulated satellite state\nsatellite_mode = \"NORMAL\"\n\n# Create a UDP socket for commands\nsock_command = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\nsock_command.bind((LISTEN_IP, COMMAND_PORT))\n\n# Create a UDP socket for telemetry\nsock_telemetry = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n\ntlm_ids = {\n    \"STATUS\": 0x4320,\n    \"PING\": 0x4321,\n    \"GET_TEMP\": 0x4322,\n    \"SET_MODE\": 0x4323,\n    \"REBOOT\": 0x4324,\n    \"ERROR\": 0x4325\n}\n\nprint(\"Satellite simulation started. Waiting for commands...\")\n\ndef send_telemetry(command,message):\n    id = tlm_ids[command]\n    fmt = '&gt;h12s'\n    packed = struct.pack(fmt, id, message.encode())\n    sock_telemetry.sendto(packed, (TELEMETRY_IP, TELEMETRY_PORT))\n    print(f\"Sent telemetry: {message}\")\n\nwhile True:\n    # Listen for commands\n    data, addr = sock_command.recvfrom(1024)  # buffer size is 1024 bytes\n    command = data.decode()\n    print(f\"Received command: {command} from {addr}\")\n\n    # Process commands\n    if command == \"STATUS\":\n        send_telemetry(command,\"STATUS:OK\")\n    elif command == \"PING\":\n        send_telemetry(command,\"PING:ACK\")\n    elif command == \"GET_TEMP\":\n        # Simulate a temperature reading\n        temp = random.randint(-50, 50)\n        send_telemetry(command,f\"TEMP:{temp}C\")\n    elif command == \"SET_MODE\":\n        # Set mode and confirm\n        satellite_mode = \"SAFE\"\n        send_telemetry(command,f\"MODE:{satellite_mode}\")\n    elif command == \"REBOOT\":\n        # Simulate a reboot sequence\n        send_telemetry(command,\"REBOOTING\")\n        satellite_mode = \"NORMAL\"  # Reset to NORMAL mode after reboot\n        send_telemetry(command,\"REBOOTED:OK\")\n    else:\n        # Unknown command\n        send_telemetry(\"ERROR\",\"UNKNOWN_CMD\")\n</code></pre> <pre><code>nano Dockerfile\n</code></pre> <pre><code># Use an official Python runtime as a parent image\nFROM python:3.8-slim\n\n# Set the working directory in the container\nWORKDIR /usr/src/app\n\n# Copy the current directory contents into the container at /usr/src/app\nCOPY . .\n\n# Run the server when the container launches\nCMD [\"python\",\"-u\", \"./sat.py\"]\n</code></pre> <p><pre><code>docker build -t byos .\n</code></pre> </p> <p><pre><code>docker run --net=openc3-cosmos-network --name byos -p1234:1234/udp -p1235:1235 --rm byos\n</code></pre> </p> <p>In new terminal window... <pre><code>cd ~/cosmos\n</code></pre></p> <p><pre><code>./openc3.sh cli generate plugin BYOS\n</code></pre> </p> <pre><code>cd openc3-cosmos-byos\n</code></pre> <p><pre><code>../openc3.sh cli generate target BYOS\n</code></pre> </p> <p><code>nano plugin.txt</code></p> <p><pre><code>VARIABLE ip 127.0.0.1\nVARIABLE port_tm 1234\nVARIABLE port_tc 1235\nVARIABLE byos_target_name BYOS\n\nTARGET BYOS &lt;%= byos_target_name %&gt;\nINTERFACE &lt;%= byos_target_name %&gt;_INT udp_interface.rb &lt;%= ip %&gt; &lt;%= port_tc %&gt; &lt;%= port_tm %&gt; nil nil 128 nil nil\n  MAP_TARGET &lt;%= byos_target_name %&gt;\n</code></pre> </p> <pre><code>cd targets/BYOS/cmd_tlm/\n</code></pre> <pre><code>nano cmd.txt\n</code></pre> <pre><code>COMMAND BYOS PING BIG_ENDIAN \"Ping Satellite\"\n  APPEND_PARAMETER CMD_STRING 0 STRING \"PING\" \"Ping Command\"\n\nCOMMAND BYOS STATUS BIG_ENDIAN \"Get Status\"\n  APPEND_PARAMETER CMD_STRING 0 STRING \"STATUS\" \"Command to Query Status\"\n\nCOMMAND BYOS GET_TEMP BIG_ENDIAN \"Get TEMP\"\n  APPEND_PARAMETER CMD_STRING 0 STRING \"GET_TEMP\" \"Command to Query Temp\"\n\nCOMMAND BYOS SET_MODE BIG_ENDIAN \"Set Satellite Mode\"\n  APPEND_PARAMETER CMD_STRING 0 STRING \"SET_MODE\" \"Command to Set Mode of Satellite\"\n\nCOMMAND BYOS REBOOT BIG_ENDIAN \"REBOOT Satellite\"\n  APPEND_PARAMETER CMD_STRING 0 STRING \"REBOOT\" \"Reboot Satellite\"\n</code></pre> <p></p> <pre><code>nano tlm.txt\n</code></pre> <p><pre><code>TELEMETRY BYOS STAUS BIG_ENDIAN \"STATUS PKT\"\n  APPEND_ID_ITEM PACKET_ID 16 UINT 0x4320 \"PACKET ID\"\n    FORMAT_STRING \"0X%04X\"\n  APPEND_ITEM RESULT 96 STRING \"RESPONSE\"\n\nTELEMETRY BYOS PING BIG_ENDIAN \"PING PKT\"\n  APPEND_ID_ITEM PACKET_ID 16 UINT 0x4321 \"PACKET ID\"\n    FORMAT_STRING \"0X%04X\"\n  APPEND_ITEM RESULT 96 STRING \"RESPONSE\"\n\nTELEMETRY BYOS TEMP BIG_ENDIAN \"TEMP PKT\"\n  APPEND_ID_ITEM PACKET_ID 16 UINT 0x4322 \"PACKET ID\"\n    FORMAT_STRING \"0X%04X\"\n  APPEND_ITEM RESULT 96 STRING \"RESPONSE\"\n\nTELEMETRY BYOS MODE BIG_ENDIAN \"MODE PKT\"\n  APPEND_ID_ITEM PACKET_ID 16 UINT 0x4323 \"PACKET ID\"\n    FORMAT_STRING \"0X%04X\"\n  APPEND_ITEM RESULT 96 STRING \"RESPONSE\"\n\nTELEMETRY BYOS REBOOT BIG_ENDIAN \"REBOOT PKT\"\n  APPEND_ID_ITEM PACKET_ID 16 UINT 0x4324 \"PACKET ID\"\n    FORMAT_STRING \"0X%04X\"\n  APPEND_ITEM RESULT 96 STRING \"RESPONSE\"\n\nTELEMETRY BYOS ERROR BIG_ENDIAN \"ERROR PKT\"\n  APPEND_ID_ITEM PACKET_ID 16 UINT 0x4325 \"PACKET ID\"\n    FORMAT_STRING \"0X%04X\"\n  APPEND_ITEM RESULT 96 STRING \"RESPONSE\"\n  ```\n\n![alt text](image-53.png)\n\n\n```bash\ncd ../../../\n../openc3.sh cli rake build VERSION=1.0.0 .\n</code></pre> </p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p>"},{"location":"cfs/","title":"NASA's Core Flight System (cFS)","text":"<p>NASA's Core Flight System (cFS) is a platform for spacecraft flight software development. It's designed to be a highly reusable, scalable, and configurable system that can support various spaceflight missions, including satellites, spacecraft, and other space-related applications. The cFS consists of a core set of reusable software components known as the Core Flight Executive (cFE), which provides the infrastructure for building flight software applications. These applications can perform various functions such as data collection, spacecraft control, and communication.</p> <p>One of the key features of the cFS is its modular architecture, which allows developers to add or modify components according to the specific needs of their mission without altering the core system. This modularity and configurability make the cFS a cost-effective and efficient solution for spaceflight software development.</p> <p>The cFS is released under the NASA Open Source Agreement (NOSA), making it freely available for anyone to use, modify, and distribute. This openness has facilitated a growing community of users and contributors from NASA, other government agencies, industry, and academia, who collaborate to improve and expand the system's capabilities.</p> <p>By providing a robust, flexible foundation for flight software development, the cFS supports NASA's missions and objectives in exploring space, advancing our understanding of the universe, and developing the technologies needed for future space exploration.</p>"},{"location":"cfs/#deploying-nasas-cfs","title":"Deploying NASA's cFS","text":"<p>The first satellite you will be deploying will be a instance of cFS running in a Docker container. This is not a fully functional or operational but is a great example of what is possible using and open-source, flight proven software, in a virtual environment. </p> <p>To get started, you need to pull the cFS Docker container from the Docker Hub, using the following command:</p> <pre><code>docker pull hackethos/cfs\n</code></pre> <p> </p> Pulling cFS Docker Container <p>Once the container image has been downloaded successfully, you can launch the container using the following command:</p> <pre><code>docker run --cap-add CAP_SYS_RESOURCE --net=openc3-cosmos-network --name cfs -p1234:1234/udp -p1235:1235 --rm hackethos/cfs\n</code></pre> <p> </p> Starting cFS Docker Container <p>After running the previous command, you should see out from the container that looks like what is shown below.</p> <p> </p> cFS Container Running <p>Now that your cFS container is running, you need to generate a plugin for COSMOS that will allow COSMOS to be able to talk to cFS and vice-versus. </p> <p>If you want to see the entire process, expand the <code>Long Version</code> section below but for the purpose of this workshop, you can skip that section.</p> Long-version <p>To generate a plugin for cFS to work with COSMOS you need to start with the following command from the <code>cosmos</code> directory.</p> <p><pre><code>./openc3.sh cli generate plugin CFS\n</code></pre> Generating cFS Plugin for COSMOS </p> <p>Next, you need to <code>cd</code> into the newly created plugin directory to generate a target with the following commands:</p> <p><pre><code>cd openc3-cosmos-cfs/\n../openc3.sh cli generate target CFS\n</code></pre> Generating cFS Target </p> <p>Now, in your favorite text editor of choice, open the <code>plugin.txt</code> file and replace the contents with the following:</p> <p><pre><code>VARIABLE ip 127.0.0.1\nVARIABLE port_tm 1235\nVARIABLE port_tc 1234\nVARIABLE cfs_target_name CFS\n\nTARGET CFS &lt;%= cfs_target_name %&gt;\n# hostname   write_dest_port   read_port   write_src_port   interface_address   ttl   write_timeout   read_timeout   bind_address\nINTERFACE &lt;%= cfs_target_name %&gt;_INT udp_interface.rb &lt;%= ip %&gt; &lt;%= port_tc %&gt; &lt;%= port_tm %&gt; nil nil 128 nil nil\nMAP_TARGET &lt;%= cfs_target_name %&gt;\n</code></pre> Save that file and then navigate to the <code>targets/CFS/cmd_tlm</code> directory and issue the following commands:</p> <p><pre><code>cd targets/CFS/cmd_tlm/\nrm *\ntouch cfs_cmds.txt cfs_tlm.txt to_lab_cmds.txt\n</code></pre> Creating Empty Files for Packet Definitions </p> <p>Now you will create your first packet definition by opening the file <code>to_lab_cmds.txt</code> and insert the following content.</p> <pre><code>COMMAND CFS TO_LAB_ENABLE BIG_ENDIAN \"Enable telemetry\"\n#                   NAME      BITS TYPE   min VAL     max VAL    init VAL  DESCRIPTION\nAPPEND_ID_PARAMETER STREAM_ID  16  UINT   0x1880      0x1880     0x1880    \"Stream ID\"\n    FORMAT_STRING \"0x%04X\"\nAPPEND_PARAMETER    SEQUENCE   16  UINT   0xC000      MAX_UINT16 0xC000    \"\"\n    FORMAT_STRING \"0x%04X\"\nAPPEND_PARAMETER    PKT_LEN    16  UINT   0x0001      0xFFFF     0x0012    \"length of the packet\"\nAPPEND_PARAMETER    CMD_ID      8  UINT   6           6          6         \"\"\nAPPEND_PARAMETER    CHECKSUM    8  UINT   MIN_UINT8   MAX_UINT8  0x98      \"\"\n    FORMAT_STRING \"0x%2X\"\nAPPEND_PARAMETER    DEST_IP   144  STRING \"127.0.0.1\"                      \"Destination IP, i.e. 172.16.9.112, pc-57\"\n</code></pre> <p>Next, open the file <code>cfs_cmds.txt</code> and insert the following content.</p> <pre><code>COMMAND CFS NOOP BIG_ENDIAN \"NOOP Command\"\n# cFS primary header\nAPPEND_ID_PARAMETER    STREAM_ID   16   UINT   0x1882      0x1882      0x1882      \"Packet Identification\"\n    FORMAT_STRING \"0x%04X\"\nAPPEND_PARAMETER       SEQUENCE    16   UINT   MIN_UINT16  MAX_UINT16  0xC000      \"\"\n    FORMAT_STRING \"0x%04X\"\nAPPEND_PARAMETER       PKT_LEN     16   UINT   0x0001      0x0001      0x0001      \"Packet length\"\n# cFS CMD secondary header\nAPPEND_PARAMETER       CMD_ID       8   UINT   0           0           0           \"\"\nAPPEND_PARAMETER       CHECKSUM     8   UINT   MIN_UINT8   MAX_UINT8   MIN_UINT8   \"\"\n\nCOMMAND CFS RESET BIG_ENDIAN \"Reset Counters Command\"\nAPPEND_ID_PARAMETER    STREAM_ID   16   UINT   0x1882      0x1882      0x1882      \"Packet Identification\"\n    FORMAT_STRING \"0x%04X\"\nAPPEND_PARAMETER       SEQUENCE    16   UINT   MIN_UINT16  MAX_UINT16  0xC000      \"\"\n    FORMAT_STRING \"0x%04X\"\nAPPEND_PARAMETER       PKT_LEN     16   UINT   0x0001      0x0001      0x0001      \"Packet length\"\nAPPEND_PARAMETER       CMD_ID       8   UINT   1           1           1           \"\"\nAPPEND_PARAMETER       CHECKSUM     8   UINT   MIN_UINT8   MAX_UINT8   MIN_UINT8   \"\"\n\nCOMMAND CFS PROCESS BIG_ENDIAN \"Process Command\"\nAPPEND_ID_PARAMETER    STREAM_ID   16   UINT   0x1882      0x1882      0x1882      \"Packet Identification\"\n    FORMAT_STRING \"0x%04X\"\nAPPEND_PARAMETER       SEQUENCE    16   UINT   MIN_UINT16  MAX_UINT16  0xC000      \"\"\n    FORMAT_STRING \"0x%04X\"\nAPPEND_PARAMETER       PKT_LEN     16   UINT   0x0001      0x0001      0x0001      \"Packet length\"\nAPPEND_PARAMETER       CMD_ID       8   UINT   2           2           2           \"\"\nAPPEND_PARAMETER       CHECKSUM     8   UINT   MIN_UINT8   MAX_UINT8   MIN_UINT8   \"\"\n</code></pre> <p>Finally, you need to open the file <code>cfs_tlm.txt</code> and insert the following content</p> <pre><code>TELEMETRY CFS HK BIG_ENDIAN \"housekeeping telemetry\"\n#                NAME       BITS  TYPE    ID      DESCRIPTION\nAPPEND_ID_ITEM   STREAM_ID   16   UINT    0x0883  \"Stream ID\"\n    FORMAT_STRING \"0x%04X\"\nAPPEND_ITEM      SEQUENCE    16   UINT            \"Packet Sequence\"\n    FORMAT_STRING \"0x%04X\"\nAPPEND_ITEM      PKT_LEN     16   UINT            \"Length of the packet\"\n# telemetry secondary header\nAPPEND_ITEM      SECONDS     32   UINT            \"\"\n        UNITS Seconds sec\nAPPEND_ITEM      SUBSECS     16   UINT            \"\"\n        UNITS Milliseconds ms\n# some bytes not known for what\nAPPEND_ITEM      SPARE2ALIGN 32   UINT            \"Spares\"\n# payload\nAPPEND_ITEM      CMD_ERRS     8   UINT            \"Command Error Counter\"\nAPPEND_ITEM      CMD_CNT      8   UINT            \"Command Counter\"\n# spare / alignment\nAPPEND_ITEM      SPARE       16   UINT            \"Spares\"\n</code></pre> <p>Lastly, you need to navigate to the root directory of your plugin and build the plugin using the following command:</p> <p><code>cd ../../../</code> and <code>../openc3.sh cli rake build VERSION=1.0.0 .</code></p> <p> Building cFS COSMOS Plugin </p> <p>If you skipped the <code>Long Version</code> you will need to download the pre-generated cFS plugin for COSMOS using the following command or downloading it from the lik that follows. If you use the link, download it from your browser in your VM.</p> <p><code>wget https://byos.ethoslabs.space/openc3-cosmos-cfs-1.0.0.gem</code></p> <p>Click Here: Download cFS Plugin</p> <p> </p> Downloading Pre-generated Plugin <p>The next step in the process is to grab the IP addresses of both your <code>cFS</code> container as well as the <code>openc3-operator</code> container. You can do this by running the following command and searching the output.</p> <p><code>docker network inspect openc3-cosmos-network</code></p> <p>Below is an example of cFS Container IP you may see.</p> <p> </p> cFS Container IP Address <p>Below is an example of the Operator Container IP you may see</p> <p> </p> OpenC3 Operator Container IP Address <p>Note</p> <p>Your IP addresses may not be in the 172.18.x.x range. That is okay.</p> <p>Now you will need to go back to COSMOS in your VM and click on the <code>Admin Console</code> section in the left side menu.</p> <p> </p> Admin Console in COSMOS <p>Then in the middle section, click on the area where is says <code>Click to select plugin...</code></p> <p> </p> Click to Install Plugin <p>A file selection popup will appear and you will need to navigate to where you cFS plugin is located and select it.</p> <p> </p> Select cFS Plugin Gem file <p>After you select your plugin file, you will get prompted to configure the plugin. Here you will need to supply the IP address of your <code>cFS</code> container as shown below.</p> <p> </p> Set IP Varible to cFS Container IP <p>After entering the IP address, you can click <code>Install</code>. It will take a few moments for the plugin to be processed but you should see a message that states the process was completed.</p> <p>Once completed, you can navigate to the <code>CmdTlmServer</code> section of COSMOS where you will see the <code>CFS_INT</code> interface as been configured and connected.</p> <p> </p> CFS_INT Connected in COSMOS <p>Next, you need to navigate to the <code>Command Sender</code> section from the left menu. ONce there, make sure that CFS is selected as the target and then select the <code>TO_LAB_ENABLE</code> Packet. With that packet selected, you will see a field called <code>DEST_IP</code> that you will need to populate with the <code>openc3-operator</code> container IP address, making sure to preserve the single quotes.</p> <p> </p> Setting DEST_IP Address in TO_LAB_ENABLE Command <p>Now you are ready to click <code>SEND</code>. In doing so, you should see an output like the one below.</p> <p> </p> Sending Telecommand Packet <p>Now, switch over to your terminal running cFS and you should see that the command was successfully received.</p> <p> </p> cFS Container Showing Telemetry Output Enabled <p>Now, back in COSMOS, if you navigate to the <code>CmdTlmServer</code> you should see that the <code>CFS_INT</code> interface is receiving TLM Packets.</p> <p> </p> COSMOS Receiving TLM Packets from cFS <p>As stated previously, this implementation of cFS is not feature complete but does demonstrate the fundamental concepts of telecommands and telemetry in a space system.</p>"},{"location":"cfs/#removing-cfs-plugin","title":"Removing cFS Plugin","text":"<p>For the next section of this workshop, you will use the same port binding that your cFS container is currently using, so you need to do a little clean up to get ready. </p> <p>First, you will navigate to the <code>Admin Console</code> section of COSMOS and find the cFS plugin and click on the trash can icon.</p> <p> </p> Deleting cFS Plugin From Admin Console <p>When prompted, click on <code>Delete</code> to remove the plugin from COSMOS.</p> <p> </p> Click Delete <p>Next, you need to switch over to your terminal running cFS and stop it using <code>CRTL + c</code></p> <p> </p> CTRL + c Terminating cFS Container <p>Once cFS stops, the container will be removed but can redeployed at anytime.</p>"},{"location":"cosmos/","title":"0x01 - OpenC3 Cosmos","text":"<p>OpenC3's COSMOS is a command and control system designed for small satellite missions. It is an evolution of the COSMOS software initially developed by Ball Aerospace, which has been widely used in the space industry for satellite command and control. COSMOS provides a comprehensive suite of tools for mission planning, telemetry and command processing, data analysis, and system simulation, making it a versatile solution for managing space missions.</p> <p>The transition to OpenC3 represents a shift towards a more open and collaborative approach to space mission control software. OpenC3 aims to foster a community where users and developers can contribute to the development and improvement of COSMOS, ensuring it remains a state-of-the-art tool for mission control. This open-source philosophy allows for greater innovation, adaptability, and cost efficiency, as users can customize the software to meet their specific mission requirements without the constraints of proprietary software licenses.</p> <p>COSMOS under OpenC3 includes features such as:</p> <ol> <li>Real-time telemetry processing: It can process and display telemetry data in real time, allowing mission operators to monitor the status and health of their spacecraft.</li> <li>Command and control capabilities: Operators can send commands to their spacecraft, automate command sequences, and ensure the safety and success of their missions.</li> <li>Data analysis and visualization: COSMOS provides tools for analyzing telemetry data, generating reports, and visualizing data trends, which are crucial for mission analysis and decision-making.</li> <li>System simulation: It can simulate spacecraft behavior and mission scenarios, helping teams test and validate their operations before execution.</li> </ol> <p>By providing these capabilities within an open-source framework, OpenC3's COSMOS enables a wide range of entities, from small startups to educational institutions and research organizations, to access sophisticated mission control software that was once the domain of large aerospace corporations and government agencies. This democratization of space technology contributes to the growing accessibility of space exploration and utilization.</p>"},{"location":"cosmos/#deploying-openc3-cosmos","title":"Deploying OpenC3 COSMOS","text":"<p>OpenC3 COMSOS is going to be the command and control system that will be utilized to simulate the Ground Segment in your BYOS virtual environment. </p> <p>To get started, you must clone the GitHub repository using the following command: <pre><code>git clone https://github.com/OpenC3/cosmos.git\n</code></pre></p> <p> </p> Cloning OpenC3 COMSOS Repository <p>Once you have cloned the repo, you can navigate into the repo using the following command: <code>cd cosmos</code>.</p> <p>Before deploying COMSOS, you first need to make a modification to the <code>compose.yaml</code> file to allow COSMOS to be able to communicate with the virtual satellites you will be deploying shortly. To make the edits, use the text editor of your choice and edit the <code>compose.yaml</code> file. One such method is using <code>nano</code>.</p> <p><pre><code>nano compose.yaml\n</code></pre> On line 161, you will find a line that contains <code># ports:</code> in the <code>openc3-operator</code> section, as shown below. <pre><code>  openc3-operator:\n    user: \"${OPENC3_USER_ID:-1001}:${OPENC3_GROUP_ID:-1001}\"\n    image: \"${OPENC3_REGISTRY}/${OPENC3_NAMESPACE}/openc3-operator${OPENC3_IMAGE_SUFFIX}:${OPENC3_TAG}\"\n    restart: \"unless-stopped\"\n    # ports:\n    #  - \"127.0.0.1:7779:7779\" # Open port for the demo router\n    depends_on:\n</code></pre></p> <p> </p> COSMOS compose.yaml Default <p>You will need to modify the <code>ports</code> section to look like the snippet below, where <code>ports:</code> is uncommented and the value <code>- \"235:1235/udp\"</code> below that.</p> <pre><code>  openc3-operator:\n    user: \"${OPENC3_USER_ID:-1001}:${OPENC3_GROUP_ID:-1001}\"\n    image: \"${OPENC3_REGISTRY}/${OPENC3_NAMESPACE}/openc3-operator${OPENC3_IMAGE_SUFFIX}:${OPENC3_TAG}\"\n    restart: \"unless-stopped\"\n    ports:\n    - \"1235:1235/udp\"\n    #  - \"127.0.0.1:7779:7779\" # Open port for the demo router\n    depends_on:\n</code></pre> <p> </p> Modified Ports Section in openc3-operator Container Config <p>If using <code>nano</code>, once you have made the changes, you can save the file with the following key sequence.</p> <p><code>CRTL + x</code>, then <code>y</code> to save.</p> <p>Having modified the <code>compose.yaml</code> file, you are now ready to deploy COSMOS.</p> <p>To deploy COSMOS, you need to run the openc3.sh shell script using the following command:</p> <pre><code>./openc3.sh run\n</code></pre> <p> </p> Running OpenC3 COSMOS <p>It will take some time for the process to run if it is the first time you are running the command, as it will need to download the necessary Docker containers.</p> <p>Once completed you should see output like what is shown below.</p> <p>Note</p> <p>If you get a permission error, trying running the previous command with <code>sudo</code>.</p> <p> </p> Startup Complete <p>You can also confirm that COSMOS is running using the <code>docekr ps</code> command, which will show all of the running containers.</p> <p> </p> Docker PS Output Showing Containers Running <p>Next in a browser in your VM, navigate to <code>http://localhost:2900</code> and you will be prompted to set a password. Feel free to chose any password you would like. Just make sure to remember it.</p> <p> </p> CSOMOS Web Interface <p>After you are logged in, you will see a screen that looks like the following:</p> <p> </p> Logged Into COSMOS"},{"location":"cosmos/#getting-the-lay-of-the-land","title":"Getting the lay of the land","text":"<p>Now that you have logged into COSMOS, it is time to get familiar with it and what it is capable of doing.</p> <p>On the left side of the screen, you will find the primary navigation menu as shown below:</p> COSMOS Sidebar Navigation <p>In the main section of your window you will the <code>CmdTlmServer</code> interface that has a row of options called <code>Interfaces</code>,<code>Targets</code>,<code>Cmd packets</code>,<code>Tlm packets</code>,<code>Routers</code>, and <code>Status</code>.</p> COSMOS CmdTlmServer Interface <p>The current deployment of COSMOS includes a demonstration plugin that has four interfaces, two of which will have a status of <code>Connected</code>.</p> Connected Interfaces with Cmd and Tlm Packets <p>If you see that the packet counts for both <code>Cmd pkts</code> and <code>Tlm pkts</code> increasing, everything is working as expected and data is coming in and from your COSMOS instance. YOu can also look below the <code>CmdTlmServer</code> window to the <code>Log Messages</code> console as shown below to see that data is flowing.</p> COSMOS Log Message Console <p>Note</p> <p>Due to time restrictions, the instructor will walk you through the rest of this section.</p>"}]}