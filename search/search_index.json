{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"BYOS - Bring Your Own Satellite","text":""},{"location":"#setting-up-your-virtual-machine","title":"Setting up your Virtual Machine","text":"<pre><code>sudo apt update &amp;&amp; sudo apt dist-upgrade -y\n</code></pre> Updating OS <pre><code>sudo apt install docker-compose -y\n</code></pre> <p>){ width=\"900\" }   </p> Installed Docker and Dependencies <pre><code>sudo groupadd docker\nsudo usermod -aG docker $USER\n</code></pre> <p>Log out and Log back in...</p> <p>open terminal and run: <code>docker version</code></p> <p> </p> Docker Version Output"},{"location":"byos/","title":"Build Your Own","text":"<p>Client <pre><code>import socket\n\n# Server address and ports\nSERVER_IP = \"localhost\"\nCOMMAND_PORT = 1234\nTELEMETRY_PORT = 1235\n\n# Create a UDP socket for commands\nsock_command = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n\n# Create a UDP socket for telemetry\nsock_telemetry = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\nsock_telemetry.bind((SERVER_IP, TELEMETRY_PORT))\n\n# Send a command to the satellite\ncommand = \"STATUS\"\nsock_command.sendto(command.encode(), (SERVER_IP, COMMAND_PORT))\nprint(f\"Sent command: {command}\")\n\n# Wait for telemetry\ndata, addr = sock_telemetry.recvfrom(1024)  # buffer size is 1024 bytes\ntelemetry = data.decode()\nprint(f\"Received telemetry: {telemetry}\")\n</code></pre></p> <p>Server <pre><code>import socket\nimport random\n\n# UDP IP and Ports\nLISTEN_IP = \"0.0.0.0\"\nCOMMAND_PORT = 1234\nTELEMETRY_PORT = 1235\nTELEMETRY_IP = \"localhost\"  # Change if the client is on a different machine\n\n# Simulated satellite state\nsatellite_mode = \"NORMAL\"\n\n# Create a UDP socket for commands\nsock_command = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\nsock_command.bind((LISTEN_IP, COMMAND_PORT))\n\n# Create a UDP socket for telemetry\nsock_telemetry = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n\nprint(\"Satellite simulation started. Waiting for commands...\")\n\ndef send_telemetry(message):\n    sock_telemetry.sendto(message.encode(), (TELEMETRY_IP, TELEMETRY_PORT))\n    print(f\"Sent telemetry: {message}\")\n\nwhile True:\n    # Listen for commands\n    data, addr = sock_command.recvfrom(1024)  # buffer size is 1024 bytes\n    command = data.decode()\n    print(f\"Received command: {command} from {addr}\")\n\n    # Process commands\n    if command == \"STATUS\":\n        send_telemetry(\"STATUS:OK\")\n    elif command == \"PING\":\n        send_telemetry(\"PING:ACK\")\n    elif command == \"GET_TEMP\":\n        # Simulate a temperature reading\n        temp = random.randint(-50, 50)\n        send_telemetry(f\"TEMP:{temp}C\")\n    elif command == \"SET_MODE\":\n        # Set mode and confirm\n        satellite_mode = \"SAFE\"\n        send_telemetry(f\"MODE:{satellite_mode}\")\n    elif command == \"REBOOT\":\n        # Simulate a reboot sequence\n        send_telemetry(\"REBOOTING\")\n        satellite_mode = \"NORMAL\"  # Reset to NORMAL mode after reboot\n        send_telemetry(\"REBOOTED:OK\")\n    else:\n        # Unknown command\n        send_telemetry(\"ERROR:UNKNOWN_COMMAND\")\n</code></pre></p>"},{"location":"cfs/","title":"NASA's Core Flight System (cFS)","text":"<p>NASA's Core Flight System (cFS) is a platform for spacecraft flight software development. It's designed to be a highly reusable, scalable, and configurable system that can support various spaceflight missions, including satellites, spacecraft, and other space-related applications. The cFS consists of a core set of reusable software components known as the Core Flight Executive (cFE), which provides the infrastructure for building flight software applications. These applications can perform various functions such as data collection, spacecraft control, and communication.</p> <p>One of the key features of the cFS is its modular architecture, which allows developers to add or modify components according to the specific needs of their mission without altering the core system. This modularity and configurability make the cFS a cost-effective and efficient solution for spaceflight software development.</p> <p>The cFS is released under the NASA Open Source Agreement (NOSA), making it freely available for anyone to use, modify, and distribute. This openness has facilitated a growing community of users and contributors from NASA, other government agencies, industry, and academia, who collaborate to improve and expand the system's capabilities.</p> <p>By providing a robust, flexible foundation for flight software development, the cFS supports NASA's missions and objectives in exploring space, advancing our understanding of the universe, and developing the technologies needed for future space exploration.</p>"},{"location":"cfs/#deploying-nasas-cfs","title":"Deploying NASA's cFS","text":"<pre><code>docker pull hackethos/cfs\n</code></pre> Pulling cFS Docker Container <pre><code>docker run --cap-add CAP_SYS_RESOURCE --net=openc3-cosmos-network --name cfs -p1234:1234/udp -p1235:1235 --rm hackethos/cfs\n</code></pre> Starting cFS Docker Container cFS Container Running <p><code>docker network inspect openc3-cosmos-network</code></p> <p>cFS Container IP</p> <p> </p> cFS Container IP Address <p>Operator Container IP</p> <p> </p> OpenC3 Operator Container IP Address <pre><code>./openc3.sh cli generate plugin CFS\n</code></pre> <p> </p> Generating cFS Plugin for COSMOS <pre><code>cd openc3-cosmos-cfs/\n../openc3.sh cli generate target CFS\n</code></pre> <p> </p> Generating cFS Target <p>Now, in your favorite text editor of choice, open the <code>plugin.txt</code> file and replace the contents with the following:</p> <pre><code>VARIABLE ip 127.0.0.1\nVARIABLE port_tm 1235\nVARIABLE port_tc 1234\nVARIABLE cfs_target_name CFS\n\nTARGET CFS &lt;%= cfs_target_name %&gt;\n# hostname   write_dest_port   read_port   write_src_port   interface_address   ttl   write_timeout   read_timeout   bind_address\nINTERFACE &lt;%= cfs_target_name %&gt;_INT udp_interface.rb &lt;%= ip %&gt; &lt;%= port_tc %&gt; &lt;%= port_tm %&gt; nil nil 128 nil nil\n  MAP_TARGET &lt;%= cfs_target_name %&gt;\n</code></pre> <pre><code>cd targets/CFS/cmd_tlm/\nrm *\ntouch cfs_cmds.txt cfs_tlm.txt to_lab_cmds.txt\n</code></pre> <p> </p> Creating Empty Files for Packet Definitions <p>Open the file <code>to_lab_cmds.txt</code> and insert the following content.</p> <pre><code>COMMAND CFS TO_LAB_ENABLE BIG_ENDIAN \"Enable telemetry\"\n  #                   NAME      BITS TYPE   min VAL     max VAL    init VAL  DESCRIPTION\n  APPEND_ID_PARAMETER STREAM_ID  16  UINT   0x1880      0x1880     0x1880    \"Stream ID\"\n    FORMAT_STRING \"0x%04X\"\n  APPEND_PARAMETER    SEQUENCE   16  UINT   0xC000      MAX_UINT16 0xC000    \"\"\n    FORMAT_STRING \"0x%04X\"\n  APPEND_PARAMETER    PKT_LEN    16  UINT   0x0001      0xFFFF     0x0012    \"length of the packet\"\n  APPEND_PARAMETER    CMD_ID      8  UINT   6           6          6         \"\"\n  APPEND_PARAMETER    CHECKSUM    8  UINT   MIN_UINT8   MAX_UINT8  0x98      \"\"\n    FORMAT_STRING \"0x%2X\"\n  APPEND_PARAMETER    DEST_IP   144  STRING \"127.0.0.1\"                      \"Destination IP, i.e. 172.16.9.112, pc-57\"\n</code></pre> <p>Next, open the file <code>cfs_cmds.txt</code> and insert the following content.</p> <pre><code>COMMAND CFS NOOP BIG_ENDIAN \"NOOP Command\"\n  # cFS primary header\n  APPEND_ID_PARAMETER    STREAM_ID   16   UINT   0x1882      0x1882      0x1882      \"Packet Identification\"\n      FORMAT_STRING \"0x%04X\"\n  APPEND_PARAMETER       SEQUENCE    16   UINT   MIN_UINT16  MAX_UINT16  0xC000      \"\"\n      FORMAT_STRING \"0x%04X\"\n  APPEND_PARAMETER       PKT_LEN     16   UINT   0x0001      0x0001      0x0001      \"Packet length\"\n  # cFS CMD secondary header\n  APPEND_PARAMETER       CMD_ID       8   UINT   0           0           0           \"\"\n  APPEND_PARAMETER       CHECKSUM     8   UINT   MIN_UINT8   MAX_UINT8   MIN_UINT8   \"\"\n\nCOMMAND CFS RESET BIG_ENDIAN \"Reset Counters Command\"\n  APPEND_ID_PARAMETER    STREAM_ID   16   UINT   0x1882      0x1882      0x1882      \"Packet Identification\"\n      FORMAT_STRING \"0x%04X\"\n  APPEND_PARAMETER       SEQUENCE    16   UINT   MIN_UINT16  MAX_UINT16  0xC000      \"\"\n      FORMAT_STRING \"0x%04X\"\n  APPEND_PARAMETER       PKT_LEN     16   UINT   0x0001      0x0001      0x0001      \"Packet length\"\n  APPEND_PARAMETER       CMD_ID       8   UINT   1           1           1           \"\"\n  APPEND_PARAMETER       CHECKSUM     8   UINT   MIN_UINT8   MAX_UINT8   MIN_UINT8   \"\"\n\nCOMMAND CFS PROCESS BIG_ENDIAN \"Process Command\"\n  APPEND_ID_PARAMETER    STREAM_ID   16   UINT   0x1882      0x1882      0x1882      \"Packet Identification\"\n      FORMAT_STRING \"0x%04X\"\n  APPEND_PARAMETER       SEQUENCE    16   UINT   MIN_UINT16  MAX_UINT16  0xC000      \"\"\n      FORMAT_STRING \"0x%04X\"\n  APPEND_PARAMETER       PKT_LEN     16   UINT   0x0001      0x0001      0x0001      \"Packet length\"\n  APPEND_PARAMETER       CMD_ID       8   UINT   2           2           2           \"\"\n  APPEND_PARAMETER       CHECKSUM     8   UINT   MIN_UINT8   MAX_UINT8   MIN_UINT8   \"\"\n</code></pre> <p>Finally, you need to open the file <code>cfs_tlm.txt</code> and insert the following content</p> <pre><code>TELEMETRY CFS HK BIG_ENDIAN \"housekeeping telemetry\"\n  #                NAME       BITS  TYPE    ID      DESCRIPTION\n  APPEND_ID_ITEM   STREAM_ID   16   UINT    0x0883  \"Stream ID\"\n    FORMAT_STRING \"0x%04X\"\n  APPEND_ITEM      SEQUENCE    16   UINT            \"Packet Sequence\"\n    FORMAT_STRING \"0x%04X\"\n  APPEND_ITEM      PKT_LEN     16   UINT            \"Length of the packet\"\n  # telemetry secondary header\n  APPEND_ITEM      SECONDS     32   UINT            \"\"\n        UNITS Seconds sec\n  APPEND_ITEM      SUBSECS     16   UINT            \"\"\n        UNITS Milliseconds ms\n  # some bytes not known for what\n  APPEND_ITEM      SPARE2ALIGN 32   UINT            \"Spares\"\n  # payload\n  APPEND_ITEM      CMD_ERRS     8   UINT            \"Command Error Counter\"\n  APPEND_ITEM      CMD_CNT      8   UINT            \"Command Counter\"\n  # spare / alignment\n  APPEND_ITEM      SPARE       16   UINT            \"Spares\"\n</code></pre> <p> </p> Building cFS COSMOS Plugin <p><code>wget https://byos.ethoslabs.space/openc3-cosmos-cfs-1.0.0.gem</code></p> <p>Click Here: Download cFS Plugin</p> <p> </p> Downloading Pre-generated Plugin <p> </p> Admin Console in COSMOS <p> </p> Click to Install Plugin <p> </p> Select cFS Plugin Gem file <p> </p> Set IP Varible to cFS Container IP <p> </p> CFS_INT Connected in COSMOS <p> </p> Setting DEST_IP Address in TO_LAB_ENABLE Command <p> </p> Sending Telecommand Packet <p> </p> cFS Container Showing Telemetry Output Enabled <p> </p> COSMOS Recieving TLM Packets from cFS"},{"location":"cfs/#removing-cfs-plugin","title":"Removing cFS Plugin","text":"Deleting cFS Plugin From Admin Console Click Delete <p><code>CRTL + c</code></p> <p> </p> CTRL + c Terminating cFS Container"},{"location":"cosmos/","title":"OpenC3 Cosmos","text":"<p>OpenC3's COSMOS is a command and control system designed for small satellite missions. It is an evolution of the COSMOS software initially developed by Ball Aerospace, which has been widely used in the space industry for satellite command and control. COSMOS provides a comprehensive suite of tools for mission planning, telemetry and command processing, data analysis, and system simulation, making it a versatile solution for managing space missions.</p> <p>The transition to OpenC3 represents a shift towards a more open and collaborative approach to space mission control software. OpenC3 aims to foster a community where users and developers can contribute to the development and improvement of COSMOS, ensuring it remains a state-of-the-art tool for mission control. This open-source philosophy allows for greater innovation, adaptability, and cost efficiency, as users can customize the software to meet their specific mission requirements without the constraints of proprietary software licenses.</p> <p>COSMOS under OpenC3 includes features such as:</p> <ol> <li>Real-time telemetry processing: It can process and display telemetry data in real time, allowing mission operators to monitor the status and health of their spacecraft.</li> <li>Command and control capabilities: Operators can send commands to their spacecraft, automate command sequences, and ensure the safety and success of their missions.</li> <li>Data analysis and visualization: COSMOS provides tools for analyzing telemetry data, generating reports, and visualizing data trends, which are crucial for mission analysis and decision-making.</li> <li>System simulation: It can simulate spacecraft behavior and mission scenarios, helping teams test and validate their operations before execution.</li> </ol> <p>By providing these capabilities within an open-source framework, OpenC3's COSMOS enables a wide range of entities, from small startups to educational institutions and research organizations, to access sophisticated mission control software that was once the domain of large aerospace corporations and government agencies. This democratization of space technology contributes to the growing accessibility of space exploration and utilization.</p>"},{"location":"cosmos/#deploying-openc3-cosmos","title":"Deploying OpenC3 COSMOS","text":"<pre><code>git clone https://github.com/OpenC3/cosmos.git\n</code></pre> Cloning OpenC3 COMSOS Repository <pre><code>cd cosmos\n</code></pre> <pre><code>nano compose.yaml\n</code></pre> <p>Line 161 <pre><code>  openc3-operator:\n    user: \"${OPENC3_USER_ID:-1001}:${OPENC3_GROUP_ID:-1001}\"\n    image: \"${OPENC3_REGISTRY}/${OPENC3_NAMESPACE}/openc3-operator${OPENC3_IMAGE_SUFFIX}:${OPENC3_TAG}\"\n    restart: \"unless-stopped\"\n    # ports:\n    #  - \"127.0.0.1:7779:7779\" # Open port for the demo router\n    depends_on:\n</code></pre></p> <p> </p> COSMOS compose.yaml Default <pre><code>  openc3-operator:\n    user: \"${OPENC3_USER_ID:-1001}:${OPENC3_GROUP_ID:-1001}\"\n    image: \"${OPENC3_REGISTRY}/${OPENC3_NAMESPACE}/openc3-operator${OPENC3_IMAGE_SUFFIX}:${OPENC3_TAG}\"\n    restart: \"unless-stopped\"\n    ports:\n    - \"1235:1235/udp\"\n    #  - \"127.0.0.1:7779:7779\" # Open port for the demo router\n    depends_on:\n</code></pre> <p> </p> Modified Ports Section in openc3-operator Container Config <p><code>CRTL + x</code>, then <code>y</code> to save.</p> <pre><code>./openc3.sh run\n</code></pre> <p> </p> Running OpenC3 COSMOS <p> </p> Startup Complete <p><code>docekr ps</code></p> <p> </p> Docker PS Output Showing Containers Running <p>In a browser in your VM, navigate to <code>http://localhost:2900</code> and you will be prompted to set a password. Feel free to chose any password you would like. Just make sure to remember it.</p> <p> </p> CSOMOS Web Interface <p>After getting logged in...</p> <p> </p> Logged Into COSMOS"},{"location":"cosmos/#getting-the-lay-of-the-land","title":"Getting the lay of the land","text":"<p>Now that you have logged into COSMOS, it is time to get familiar with it and what it is capable of doing.</p> <p>On the left side of the screen, you will find the primary navigation menu as shown below:</p> COSMOS Sidebar Navigation <p>In the main section of your window you will the <code>CmdTlmServer</code> interface that has a row of options called <code>Interfaces</code>,<code>Tagrets</code>,<code>Cmd packets</code>,<code>Tlm packets</code>,<code>Routers</code>, and <code>Status</code>.</p> COSMOS CmdTlmServer Interface <p>The current deployment of COSMOS includes a demonstration plugin that has four interfaces, two of which will have a status of <code>Connected</code>.</p> Connected Interfaces with Cmd and Tlm Packets <p>If you see that the packet counts for both <code>Cmd pkts</code> and <code>Tlm pkts</code> increasing, everyhing is working as expected and data is coming in and from your COSMOS instance. YOu can also look below the <code>CmdTlmServer</code> window to the <code>Log Messages</code> console as shown below to see that data is flowing.</p> COSMOS Log Messge Console"}]}